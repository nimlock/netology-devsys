# Домашнее задание к занятию "4.2. Использование Python для решения типовых DevOps задач"

## Модуль 4. Скриптовые языки и языки разметки: Python, Bash, YAML, JSON

### Студент: Иван Жиляев

## Обязательные задания

1. >Есть скрипт:
	>```python
   > #!/usr/bin/env python3
	>a = 1
	>b = '2'
	>c = a + b
	>```
	>* Какое значение будет присвоено переменной c?
	>* Как получить для переменной c значение 12?
	>* Как получить для переменной c значение 3?

   Ответ:
   - переменная `c` будет неопределена, т.к. пытаемся сложить переменные различного типа - будет ошибка исполнения кода

   - чтобы получить строковое значение `'12'` нужно преобразовать `a` к типу _string_, что приведёт к возможности конкатенации строк
      ```
      a = str(a)
      ```

   - требуется преобразовать переменную `b` к типу _integer_
      ```
      b = int(b)
      ```

   Все предположения оказались верны при проверке.

1. >Мы устроились на работу в компанию, где раньше уже был DevOps Engineer. Он написал скрипт, позволяющий узнать, какие файлы модифицированы в репозитории, относительно локальных изменений. Этим скриптом недовольно начальство, потому что в его выводе есть не все изменённые файлы, а также непонятен полный путь к директории, где они находятся. Как можно доработать скрипт ниже, чтобы он исполнял требования вашего руководителя?
   >
	>```python
   > #!/usr/bin/env python3
   >
   > import os
   >
	>bash_command = ["cd ~/netology/sysadm-homeworks", "git status"]
	>result_os = os.popen(' && '.join(bash_command)).read()
   > is_change = False
	>for result in result_os.split('\n'):
   >     if result.find('modified') != -1:
   >         prepare_result = result.replace('\tmodified:   ', '')
   >         print(prepare_result)
   >         break
   >
	>```

   Разберём данный скрипт. В `bash_command` содержится список команд для оболочки, с помощью которых мы получаем статус репозитория. Затем, разбирая этот статус построчно, в случае присутствия подстроки `modified` немного форматируем строку и выводим её значение.  
   Строка с определением переменной `is_change` бессмысленна. 

   Проблема с тем, что начальство видит не все изменённые файлы, порождена наличием `break`, который завершает перебор строк статуса репозитория после первой совпадающей с шаблоном строкчи.  
   Полный путь в выводе мы сможем получить сделав конкатенацию пути к репозиторию и относительного пути к изменённым файлам. Если путь к репозиторию был построен от домашнего каталога `~/`, то скрипт раскроет его до абсолютного.

   Скрипт расположен в этом же репозитории - [print_git_modifyed.py](print_git_modifyed.py)

   _Прим.: Для упрощения итогового скрипта буду считать, что скрипту передаётся корень репозитория. Поместим его расположение в переменную REPO_PATH_

   ```python
   #!/usr/bin/env python3

   import os

   REPO_PATH = '~/netology/sysadm-homeworks'
   HOME_FULLPATH = os.popen('echo -n $HOME').read()

   if REPO_PATH.find('~', 1, 1):
       REPO_FULLPATH = REPO_PATH.replace("~", HOME_FULLPATH, 1)
   else:
       REPO_FULLPATH = REPO_PATH

   bash_command = [f"cd {REPO_FULLPATH}", "git status"]
   result_os = os.popen(' && '.join(bash_command)).read()
   for result in result_os.split('\n'):
       if result.find('modified') != -1:
           prepare_result = result.replace('\tmodified:   ', '')
           print(REPO_FULLPATH + "/" + prepare_result)
   ```

1. >Доработать скрипт выше так, чтобы он мог проверять не только локальный репозиторий в текущей директории, а также умел воспринимать путь к репозиторию, который мы передаём как входной параметр. Мы точно знаем, что начальство коварное и будет проверять работу этого скрипта в директориях, которые не являются локальными репозиториями.

   Планирую внедрить следующие изменения в код:
   - проверять есть ли у скрипта входной параметр
      - если его нет, то записать в `REPO_PATH` путь соответствующему выводу `pwd`
      - если параметр есть, записать его в `REPO_PATH`
   - проверять находится ли в расположении `REPO_PATH` git-репозиторий поиском директории `./.git` (нарочно упрощаю логику скрипта, считая, что должен быть передан путь именно к корню репозитория)
      - если такая папка есть, выполнить поиск модификаций файлов
      - если папки нет, вывести ошибку

   ```python
   #!/usr/bin/env python3

   import os
   import sys

   if len(sys.argv) >= 2:        # Проверка наличия аргумента
       INPUT_PATH = sys.argv[1]
   else:
       INPUT_PATH = os.getcwd()

   DOT_GIT_PATH = INPUT_PATH + "/.git"

   if os.access(DOT_GIT_PATH, os.F_OK):   # Проверка наличия .git
       REPO_PATH = INPUT_PATH
   else:
       print("[ERROR] This is not git-repo!")
       sys.exit()

   bash_command = [f"cd {REPO_PATH}", "git status"]
   result_os = os.popen(' && '.join(bash_command)).read()
   for result in result_os.split('\n'):
       if result.find('modified') != -1:
           prepare_result = result.replace('\tmodified:   ', '')
           print(REPO_PATH + "/" + prepare_result)
   ```

1. >Наша команда разрабатывает несколько веб-сервисов, доступных по http. Мы точно знаем, что на их стенде нет никакой балансировки, кластеризации, за DNS прячется конкретный IP сервера, где установлен сервис. Проблема в том, что отдел, занимающийся нашей инфраструктурой очень часто меняет нам сервера, поэтому IP меняются примерно раз в неделю, при этом сервисы сохраняют за собой DNS имена. Это бы совсем никого не беспокоило, если бы несколько раз сервера не уезжали в такой сегмент сети нашей компании, который недоступен для разработчиков. Мы хотим написать скрипт, который опрашивает веб-сервисы, получает их IP, выводит информацию в стандартный вывод в виде: <URL сервиса> - <его IP>. Также, должна быть реализована возможность проверки текущего IP сервиса c его IP из предыдущей проверки. Если проверка будет провалена - оповестить об этом в стандартный вывод сообщением: [ERROR] <URL сервиса> IP mismatch: <старый IP> <Новый IP>. Будем считать, что наша разработка реализовала сервисы: drive.google.com, mail.google.com, google.com.

   Напишем скрипт для однократной ручной (не циклической фоновой) проверки списка доменных имён сервисов с сохранением статуса последней проверки в файл. Домены будут заданы в виде кортежа в теле скрипта.  
   Код из файла скрипта [check_domains.py](check_domains.py) продублирован здесь:

   ```python
   #!/usr/bin/env python3

   import socket
   import json

   result_file = "check_domains_results.json"     # Файл, в котором хранятся результаты прошлого выполнения скрипта

   # Формирование словаря прошлых результатов
   try:                        # Пробуем считать прошлые результаты из файла
       with open(result_file, 'r') as f:
           previous_ip_dict = json.load(f)
   except FileNotFoundError:
       print('[WARN] Previous results not found!')
       previous_ip_dict = {}

   # Определяем словарь для свежих результатов работы скрипта
   current_ip_dict = {}

   # Кортеж из доменов для проверки
   SERVICES_DOMAINS = (
       'drive.google.com',
       'mail.google.com',
       'google.com'
   )

   # Формирование словаря текущих адресов
   for domain in SERVICES_DOMAINS:                 # Перебираем имеющиеся домены
       current_ip = socket.gethostbyname(domain)   # Записываем текущий ip в переменную
       current_ip_dict[domain] = current_ip        # Заполняем

   # Сравнение старого и нового адреса
   for key in current_ip_dict:
       newIP = current_ip_dict[key]
       print(' - '.join([key, newIP]))

       # Проверим что у нас есть старый адрес для этого домена, если нет - следующая итерация
       try:
           oldIP = previous_ip_dict[key]
       except KeyError:
           print(f'[WARN] Previous IP for {key} not found!')
           continue

       # Сравним старый и текущий адрес ресурса
       if newIP != oldIP:
           print('[ERROR]', key, 'IP mismatch:', 'previous -', oldIP, 'now -', newIP)

   # Записываем результаты в файл
   with open(result_file, 'w') as f:
       json.dump(current_ip_dict, f, indent='    ')
   ```

## Дополнительное задание (со звездочкой*) - необязательно к выполнению

>Так получилось, что мы очень часто вносим правки в конфигурацию своей системы прямо на сервере. Но так как вся наша команда разработки держит файлы конфигурации в github и пользуется gitflow, то нам приходится каждый раз переносить архив с нашими изменениями с сервера на наш локальный компьютер, формировать новую ветку, коммитить в неё изменения, создавать pull request (PR) и только после выполнения Merge мы наконец можем официально подтвердить, что новая конфигурация применена. Мы хотим максимально автоматизировать всю цепочку действий. Для этого нам нужно написать скрипт, который будет в директории с локальным репозиторием обращаться по API к github, создавать PR для вливания текущей выбранной ветки в master с сообщением, которое мы вписываем в первый параметр при обращении к py-файлу (сообщение не может быть пустым). При желании, можно добавить к указанному функционалу создание новой ветки, commit и push в неё изменений конфигурации. С директорией локального репозитория можно делать всё, что угодно. Также, принимаем во внимание, что Merge Conflict у нас отсутствуют и их точно не будет при push, как в свою ветку, так и при слиянии в master. Важно получить конечный результат с созданным PR, в котором применяются наши изменения.

   Для упрощения работы скрипта воспользуемся сторонними модулями, которые необходимо установить:
   ```
   # https://github.com/PyGithub/PyGithub
   # Docs: https://pygithub.readthedocs.io/en/latest/introduction.html
   pip3 install PyGithub
   
   # https://github.com/gitpython-developers/GitPython
   # Docs: https://gitpython.readthedocs.io/en/stable/tutorial.html
   pip3 install GitPython
   ```

   Скрипт расположен в этом же репозитории - [git_automat.py](git_automat.py)

   ### Нюансы работы скрипта:
   - скрипт ожидает на вход от 2 до 5 аргументов
   - первым аргументом должно быть желаемое действие из списка
      - `i_want_branch`: второй аргумент (обязатлеьный) - название ветки, которую, если её нет, необходимо создать и переключиться в неё.
      - `commit_push`: делает commit и push подготовленных изменений; обязательно указать в аргументе сообщение для коммита.
      - `make_pr`: делает PR в ветку master на GitHub; обязательно указать в аргументе сообщение для PR.
      - `combo`: создаёт/переключает ветку, делает commit, push, а затем PR в master; обязательно указывать имя ветки, сообщение коммита и сообщение PR. 
   - для действий `commit_push` и `make_pr` возможно указать вторым аргументом название желаемой ветки, а уже третим - комментарий; по-умолчанию будет использоваться текущая активная ветка
   - перед началом использования рекомендуется проверить/исправить параметры его работы, например: учётные данные от GitHub и имя целевого репозитория, псевдоним для remote, куда будет производиться push и т.д.

   ### Примеры использования:
   - Создать, если отсутствует, ветку _some_feature_ и сделать chechout в неё:
      ```
     python3 git_automat.py i_want_branch some_feature
     ```
     
   - Создать коммит в текущей ветке с комментарием "_Add some config_" и запушить его:
     ```
     python3 git_automat.py commit_push 'Add some config'
     ```

   - Создать новую ветку (или просто переключиться, если ветка имеется) _new_branch_, сделать коммит подгтовленных изменений с комментарием "_Change parameters_" и запушить:
     ```
     python3 git_automat.py commit_push new_branch 'Change parameters'
     ```

   - Создать PR в master для текущей ветки с комментарием "_I`ve finished that task_":
     ```
     python3 git_automat.py make_pr 'I`ve finished that task'
     ```

   - "Всё и сразу": создать/переключиться в ветку _cool_stuff_, закоммитить всё подготовленное с сообщением "_All work very well_", запушить всё в remote и сделать PR в master с комментарием "_Great new thing is ready!_":
     ```
     python3 git_automat.py combo cool_stuff 'All work very well' 'Great new thing is ready!'
     ```
