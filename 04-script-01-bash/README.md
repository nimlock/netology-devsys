# Домашнее задание к занятию "4.1. Командная оболочка Bash: Практические навыки"

## Модуль 4. Скриптовые языки и языки разметки: Python, Bash, YAML, JSON

### Студент: Иван Жиляев

## Обязательные задания

1. >Есть скрипт:
	>```bash
	>a=1
	>b=2
	>c=a+b
	>d=$a+$b
	>e=$(($a+$b))
	>```
	>* Какие значения переменным c,d,e будут присвоены?
	>* Почему?

   В переменной `c` будет находиться строка с содержимым `a+b`, т.к. после оператора присваивания нет никаких экранирующих символов.

   Переменная `d` будет являться также строкой, но с содержимым `1+2`, так как парсер при разборе подставит соответствующие значения переменных. Это произойдёт благодаря символу `$` перед именами переменных.

   Переменная `e` будет содержать результат арифметического сложения значений указанных переменных, так как использованная конструкция синтаксиса позволяет применять простейшие математические функции даже к переменным, которые были заданы не явно и поэтому имеют тип "строка".

1. >На нашем локальном сервере упал сервис и мы написали скрипт, который постоянно проверяет его доступность, записывая дату проверок до тех пор, пока сервис не станет доступным. В скрипте допущена ошибка, из-за которой выполнение не может завершиться, при этом место на Жёстком Диске постоянно уменьшается. Что необходимо сделать, чтобы его исправить:
	>```bash
	>while ((1==1)
	>do
	>curl https://localhost:4757
	>if (($? != 0))
	>then
	>date >> curl.log
	>fi
	>done
	>```

   В приведённом цикле условие `1==1` всегда истино, так что цикл для завершения должен содержать ключевое слово `break`. Учитывая структуру скрипта оптимально будет расположить его в секции `else` в проверке статуса сервиса:

   ```
	while ((1==1))
	do
	curl https://localhost:4757
	if (($? != 0))
	then
	date >> curl.log
	else
	break
	fi
	done
   ```

   _Прим.: В блоке кода к заданию не хватает ")" в описании условия цикла_

1. >Необходимо написать скрипт, который проверяет доступность трёх IP: 192.168.0.1, 173.194.222.113, 87.250.250.242 по 80 порту и записывает результат в файл log. Проверять доступность необходимо пять раз для каждого узла.

   Используем полученные знания и используем массив:

   ```
   #!/usr/bin/env bash

   ip_to_check=("192.168.0.1" "173.194.222.113" "87.250.250.242")
   wait_time=1   #Время между проверками
   check_timeout=1   #Таймаут одной проверки
   check_count=5   #Количество проверок для каждого хоста

   echo "" > log   #Очистим log-файл

   for address in ${ip_to_check[@]}
   do
      n=$check_count
      while ((n>0)) 
      do
         curl --connect-timeout ${check_timeout} http://${address} >/dev/null 2>&1
         state=$?
         echo "Checking host ${address}, status is ${state}" >> log
         if ((state==0))
         then
            sleep ${wait_time}
         fi
         let "n -= 1"
      done
   done

   ```

1. >Необходимо дописать скрипт из предыдущего задания так, чтобы он выполнялся до тех пор, пока один из узлов не окажется недоступным. Если любой из узлов недоступен - IP этого узла пишется в файл error, скрипт прерывается

   Так как условие завершения цикла нельзя задать явно, воспользуемся `while`:

   ```
   #!/usr/bin/env bash

   ip_to_check=("192.168.0.1" "173.194.222.113" "87.250.250.242")
   wait_time=1   #Время между проверками
   check_timeout=1   #Таймаут одной проверки

   while ((1==1))   #Добавим бесконечный цикл
   do
      for address in ${ip_to_check[@]}
      do
         echo $(date) - new iteration for ${address}   #Для дебага
         curl --connect-timeout ${check_timeout} http://${address} >/dev/null 2>&1
         state=$?
         if ((state!=0))
         then
            echo "Host ${address} failed check, status is ${state}" > error
            echo $(date) - check fail   #Для дебага
            exit 1
         fi
         echo $(date) - check ok   #Для дебага
      done

      sleep ${wait_time}
   done
   ```

## Дополнительное задание (со звездочкой*) - необязательно к выполнению

>Мы хотим, чтобы у нас были красивые сообщения для коммитов в репозиторий. Для этого нужно написать локальный хук для git, который будет проверять, что сообщение в коммите содержит код текущего задания в квадратных скобках и количество символов в сообщении не превышает 30. Пример сообщения: \[04-script-01-bash\] сломал хук

   Пример сообщения из задания вызывает диссонанс: полная длина строки __не превышает__ 30 знаков, однако смысл сообщения намекает на то, что такой коммит не должен пройти.

   ```
   vagrant@vagrant:~$ echo -n "[04-script-01-bash] сломал хук" | wc -m
   30
   ```

   Что касается сути задания: за пример был взят хук `.git/hooks/commit-msg.sample` - рабочий хук должен именоваться `commit-msg` и иметь метку исполняемого файла.  
   Скрипт поочерёдно проверяет заданные условия:

   - сперва по регулярному выражению проверяется соответствие сообщения шаблону
   
   - затем проверяется общая длина строки. Она сравнивается с числом `31`, а не `30`, из-за символа перевода строки, который `wc` учитывает при работе

   ```
   #!/bin/sh
   #

   #Если вывод grep пуст, значит сообщение не соответствует шаблону
   test -n "$(grep -P '^\[\d{2,}-\w+-\d{2,}-\w+\].+' $1)" || {
           echo >&2 Commit message doesn\`t match template.
           exit 1
   }

   #Оцениваем количество знаков в сообщении, учитывая перевод строки
   test "$(wc -m < $1)" -le "31" || {
           echo >&2 Commit message contain over than 30 symbols.
           exit 1
   }
   ```
