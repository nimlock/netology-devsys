# Домашнее задание к занятию "3.6. Компьютерные сети, лекция 1"

## Модуль 3. Основы системного администрирования

## Студент: Иван Жиляев

Ответы на вопросы из задания:

1. >Необязательное задание:
можно посмотреть целый фильм в консоли `telnet towel.blinkenlights.nl` :)

   Вау, вот это энтузиазм ))

1. >Узнайте о том, сколько действительно независимых (не пересекающихся) каналов есть в разделяемой среде WiFi при работе на 2.4 ГГц. Стандарты с полосой 5 ГГц более актуальны, но регламенты на 5 ГГц существенно различаются в разных странах, а так же не раз обновлялись. В качестве дополнительного вопроса вне зачета, попробуйте найти актуалый ответ и на этот вопрос.

   Если говорить о Wi-Fi 2.4 ГГц, то у него __три__ не пересекающихся калана.  
   У Wi-Fi 5 ГГц, конечно, всё сложнее и запутаннее. Я смог выяснить, что для России (для частного использования) можно использовать две частотные полосы: UNII-1 (5150–5250 MHz) и UNII-2 (5250–5350 MHz). В каждой можно выделить по 4 неперекрывающихся канала шириной 20MHz, итого __восемь__ каналов.

1. >Адрес канального уровня – MAC адрес – это 6 байт, первые 3 из которых называются OUI – Organizationally Unique Identifier или уникальный идентификатор организации. Какому производителю принадлежит MAC `38:f9:d3:55:55:79`?

   Этот MAC входит в диапазон, зарегистрированный за компанией __Apple, Inc__ (данные с портала [https://macaddress.io](https://macaddress.io)).

1. >Каким будет payload TCP сегмента, если Ethernet MTU задан в 9001 байт, размер заголовков IPv4 – 20 байт, а TCP – 32 байта?

   Насколько я понял, лимит на размер payload зависит только от величины MTU, определяемой для канального уровня; другие уровни подстраиваются под это значение.  
   В этом случае, для поиска ответа нам надо из величины MTU (9001 байт) вычесть размер заголовков IPv4 (20 байт) и TCP (32 байта). Получается __8949 байт__.

1. >Может ли во флагах TCP одновременно быть установлены флаги SYN и FIN при штатном режиме работы сети? Почему да или нет?

   Нет, в штатном режиме эти флаги не могут быть установлены в одном пакете одновременно, т.к. они обозначают логически противоположные вещи: SYN - это запрос на установление соединения, а FIN - запрос на закрытие.

1. >`ss -ula sport = :53` на хосте имеет следующий вывод:
   >
   >```bash
   >State           Recv-Q          Send-Q                   Local Address:Port                     Peer Address:Port          Process
   >UNCONN          0               0                        127.0.0.53%lo:domain                        0.0.0.0:*
   >```
   >
   >Почему в `State` присутствует только `UNCONN`, и может ли там присутствовать, например, `TIME-WAIT`?

   Всё дело в том, что на 53 порту работает протокол DNS, который использует в качестве транспорта протокол UDP, который работает без установки соединения (сессии) - поэтому статус `UNCONN` ("не соединён"). Кроме того, в поле `State` мы не сможем наблюдать (характерный для протокола TCP) статус `TIME-WAIT`.

7. >Обладая знаниями о том, как штатным образом завершается соединение (FIN от инициатора, FIN-ACK от ответчика, ACK от инициатора), опишите в каких состояниях будет находиться TCP соединение в каждый момент времени на клиенте и на сервере при завершении. Схема переходов состояния соединения вам в этом поможет.

   Предположим, что мы будем наблюдать за ситуацией, когда клиент решил закрыть соединение со статусом `ESTABLISHED`:

   - клиент отправляет серверу пакет с флагом `FIN`, соединение переводит в статус `FIN_WAIT_1`

   - сервер получив запрос на закрытие соединения переводит соединение в статус `CLOSE_WAIT` и отправляет в ответ `ACK` как подтверждение инициации закрытия

   - клиент, получив подтверждение, меняет статус соединения на `FIN_WAIT_2`, на сервер ничего не посылается

   - сервер, завершив отправку ранее запрошенных данных, отправляет пакет с флагом `FIN` и переводит соединение в `LAST_ACK`

   - клиент в ответ отправляет `ACK` и переходит в `TIME_WAIT` для ожидания доставки возможных потерянных пакетов; через некий таймаут соединение закрывается

   - сервер получив последний `ACK` закрывает соединение

1. >TCP порт – 16 битное число. Предположим, 2 находящихся в одной сети хоста устанавливают между собой соединения. Каким будет теоретическое максимальное число соединений, ограниченное только лишь параметрами L4, которое параллельно может установить клиент с одного IP адреса к серверу с одним IP адресом? Сколько соединений сможет обслужить сервер от одного клиента? А если клиентов больше одного?

   Мне кажется, что в ситуации с 2-мя хостами теоретическое максимальное число TCP-соединений можно найти следуя такой логике, что клиент сперва может использовать поочерёдно все свои порты для подключения к первому порту сервера, затем также все свои порты для подключения ко второму порту сервера и т.д.  В десятичной записи 16 битное число может принимать 65 536 значения. Значит нужно возвести это число в квадрат - лимит равен __4 294 967 296 соединений__.  
   Последние вопросы, как я понял, отменяют принятое ограничение. Сервер будет ограничен количеством дескрипторов, которые он может создать под сокеты соединений. В прошлых заданиях мы выяснили, что этот лимит по файловым дескрипторам в ядре определён параметром `fs.nr_open` и равен 1048576 и может быть увеличен.

1. >Может ли сложиться ситуация, при которой большое число соединений TCP на хосте находятся в состоянии  `TIME-WAIT`? Если да, то является ли она хорошей или плохой? Подкрепите свой ответ пояснением той или иной оценки.

   Такая ситуация возможна, если рассматриваемый хост в ходе работы производит много исходящих соединений. Соединения в статусе `TIME-WAIT` продолжают держать сокет открытым, что может привести к их исчерпанию - новые соединения перестанут создаваться.

1. >Чем особенно плоха фрагментация UDP относительно фрагментации TCP?

   Предполагаю, что фрагментация UDP плоха тем, что кратно количеству получившихся фрагментов снижается надёжность передачи данных - достаточно "пропасть" одному фрагменту и вся дейтаграмма не будет прочитана получателем.  
   _Прим.: Ответ, на самом деле, "притянут", т.к. ничего более внятного в ходе рассуждений и поиска не нашлось. Оба протокола фрагментирует низлежащий IP; при проблемах с передачей фрагментов TCP переотправит данные, а UDP - нет, не вижу разницы была фрагментация или нет._

1. >Если бы вы строили систему удаленного сбора логов, то есть систему, в которой несколько хостов отправяют на центральный узел генерируемые приложениями логи (предположим, что логи – текстовая информация), какой протокол транспортного уровня вы выбрали бы и почему? Проверьте ваше предположение самостоятельно, узнав о стандартном протоколе syslog.

   Я бы выбрал TCP, так как потери данных при передаче логов считаю недопустимыми. Проблему высокой нагрузки на сеть из-за служебных сегментов TCP предпочту компенсировать настройкой уровня журналирования (чтобы лишнее не писалось). UDP применил бы только при возможности проверки целостности данных на верхних уровнях модели ISO/OSI.  
   В описаниях `syslog` говорится, что приоритет у него на использование порта 514 UDP, однако в [Вики](https://ru.wikipedia.org/wiki/Syslog) такое предпочтение не зафиксировано и в перечне используемых портов есть два TCP, видимо не так уж всё однозначно.

1. >Сколько портов TCP находится в состоянии прослушивания на вашей виртуальной машине с Ubuntu, и каким процессам они принадлежат?

   Эту информацию можно получить выполнив команду `ss -ltnp4`:

   ```
   root@vagrant:~# ss -ltnp4
   State              Recv-Q             Send-Q                         Local Address:Port                         Peer Address:Port             Process                                                               
   LISTEN             0                  4096                                 0.0.0.0:111                               0.0.0.0:*                 users:(("rpcbind",pid=607,fd=4),("systemd",pid=1,fd=35))             
   LISTEN             0                  4096                           127.0.0.53%lo:53                                0.0.0.0:*                 users:(("systemd-resolve",pid=608,fd=13))                            
   LISTEN             0                  128                                  0.0.0.0:22                                0.0.0.0:*                 users:(("sshd",pid=926,fd=3))
   ```

   Видно, что работают три демона:

   - sshd на 22 порту
   - systemd-resolve на 53 порту
   - rpcbind на 111 порту

1. >Какой ключ нужно добавить в `tcpdump`, чтобы он начал выводить не только заголовки, но и содержимое фреймов в текстовом виде? А в текстовом и шестнадцатиричном?

   Содержимое фреймов в текстовом виде можно увидеть с ключом `-A`. Для вывода содержимого в текстовом и шестнадцатиричном виде нужно использовать ключ `-X`.

1. >Попробуйте собрать дамп трафика с помощью `tcpdump` на основном интерфейсе вашей виртуальной машины и посмотреть его через tshark или Wireshark (можно ограничить число пакетов `-c 100`). Встретились ли вам какие-то установленные флаги Internet Protocol (не флаги TCP, а флаги IP)? Узнайте, какие флаги бывают. Как на самом деле называется стандарт Ethernet, фреймы которого попали в ваш дамп? Можно ли где-то в дампе увидеть OUI?

   В дампе были ip-пакеты с флагом `DF`, который запрещает фрагментацию этого пакета при передаче. Фалг второго возможного типа `MF` (означает что последовательность фрагментов ещё не закончена) не встречался.

   Из интерфейса Wireshark видно, что фреймы относятся к стандарту `Ethernet II`. Также Wireshark сам делает сопоставление первых трёх битов MAC с базой OUI.
