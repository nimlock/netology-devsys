# Домашнее задание к занятию "3.3. Операционные системы, лекция 1"

## Модуль 3. Основы системного администрирования

## Студент: Иван Жиляев

Ответы на вопросы из задания:

1. >Какой системный вызов делает команда `cd`? В прошлом ДЗ мы выяснили, что `cd` не является самостоятельной  программой, это `shell builtin`, поэтому запустить `strace` непосредственно на `cd` не получится. Тем не менее, вы можете запустить `strace` на `/bin/bash -c 'cd /tmp'`. В этом случае вы увидите полный список системных вызовов, которые делает сам `bash` при старте. Вам нужно найти тот единственный, который относится именно к `cd`.

   _Прим.: Пожалуй, было бы интереснее убрать пояснения к заданию под спойлер._
   
   С помощью вывода команды `strace /bin/bash -c 'cd /tmp'` становится ясно, что смена рабочей директории текущего процесса происходит через системный вызов `chdir`. Информация о нём доступна черз команду `man 2 chdir`.

1. >Попробуйте использовать команду `file` на объекты разных типов на файловой системе. Например:
   >```bash
   >vagrant@netology1:~$ file /dev/tty
   >/dev/tty: character special (5/0)
   >vagrant@netology1:~$ file /dev/sda
   >/dev/sda: block special (8/0)
   >vagrant@netology1:~$ file /bin/bash
   >/bin/bash: ELF 64-bit LSB shared object, x86-64
   >```
   >Используя `strace` выясните, где находится база данных `file` на основании которой она делает свои догадки.

   Команда `file` имеет целый алгоритм определения файла(-ов) с БД. Конкретно на тестовом стенде БД располагается в файле `/usr/share/misc/magic.mgc`.

   Если рассматривать вывод `strace` и отбросить неудачные попытки перебора пути к БД, то вот строки, в которых идёт работа с актуальной базой:
   
   ```
   ...
   openat(AT_FDCWD, "/usr/share/misc/magic.mgc", O_RDONLY) = 3
   fstat(3, {st_mode=S_IFREG|0644, st_size=5811536, ...}) = 0
   mmap(NULL, 5811536, PROT_READ|PROT_WRITE, MAP_PRIVATE, 3, 0) = 0x7fcc83dd6000
   close(3)                                = 0
   mprotect(0x7fcc83dd6000, 5811536, PROT_READ) = 0
   ...
   ```

   Интерпретация вывода:

   - файл открывается для чтения, используется файловый дескриптор `3`
   - читается размер файла в байтах - параметр `st_size`
   - выделяется область памяти и в неё отображается содержимое файла, возвращается указатель на эту область памяти
   - файл закрывается
   - выделенной области памяти назначается уровень доступа "чтение" - профит, база в распоряжении `file`

1. >Предположим, приложение пишет лог в текстовый файл. Этот файл оказался удален (deleted в lsof), однако возможности сигналом сказать приложению переоткрыть файлы или просто перезапустить приложение – нет. Так как приложение продолжает писать в удаленный файл, место на диске постепенно заканчивается. Основываясь на знаниях о перенаправлении потоков предложите способ обнуления открытого удаленного файла (чтобы освободить место на файловой системе).

   В описанной ситуации можно с помощью `lsof` сперва определить какой файловый дескриптор выделен для работы с удалённым файлом, а затем любым удобным способом очистить его содержимое обратившись по пути файлового дескриптора в `/proc`.
   
   Как пример, на тестовом стенде для очистки я применил такую конструкцию:

   ```
   echo "" > /proc/1667/fd/3 
   ```

1. >Занимают ли зомби-процессы какие-то ресурсы в ОС (CPU, RAM, IO)?

   Единственный потребляемый зомби-процессами ресурс - это пул PID-ов (ресурс ядра). Объяснение простое: самого процесса уже нет, осталась лишь запись о нём в таблице процессов с кодом выхода.  
   В случае переполнения этой таблицы новые процессы не будут созданы, т.к. нарушится механика работы системных вызовов `fork|clone`.

1. >В iovisor BCC есть утилита `opensnoop`:
   >```bash
   >root@vagrant:~# dpkg -L bpfcc-tools | grep sbin/opensnoop
   >/usr/sbin/opensnoop-bpfcc
   >```
   >На какие файлы вы увидели вызовы группы `open` за первую секунду работы утилиты? Воспользуйтесь пакетом `bpfcc-tools` для Ubuntu 20.04. Дополнительные [сведения по установке](https://github.com/iovisor/bcc/blob/master/INSTALL.md).

   Утилита за первую секунду предоставила следующий вывод:

   ```
   vagrant@vagrant:~$ sudo opensnoop-bpfcc 
   PID    COMM               FD ERR PATH
   769    vminfo              4   0 /var/run/utmp
   569    dbus-daemon        -1   2 /usr/local/share/dbus-1/system-services
   569    dbus-daemon        18   0 /usr/share/dbus-1/system-services
   569    dbus-daemon        -1   2 /lib/dbus-1/system-services
   ```

   _Прим.: Функционал утилит в `bpfcc-tools` потрясающий! Спасибо, что познакомили с этим пакетом =)_

1. >Какой системный вызов использует `uname -a`? Приведите цитату из man по этому системному вызову, где описывается альтернативное местоположение в `/proc`, где можно узнать версию ядра и релиз ОС.

   С помощью команды `strace uname -a` видно, что используется эффективный вызов `uname()`.  
   А вот цитата из `man 2 uname`, сообщающая об альтернативном расположении интересующих данных:

   ```
   Part of the utsname information is also accessible via /proc/sys/kernel/{ostype, hostname, osrelease, version, domainname}.
   ```

   Проверка показала, что так и есть:

   ```
   vagrant@vagrant:~$ cat /proc/sys/kernel/osrelease 
   5.4.0-47-generic
   vagrant@vagrant:~$ cat /proc/sys/kernel/version 
   #51-Ubuntu SMP Fri Sep 4 19:50:52 UTC 2020
   ```

1. >Чем отличается последовательность команд через `;` и через `&&` в bash? Например:
   >```bash
   >root@netology1:~# test -d /tmp/some_dir; echo Hi
   >Hi
   >root@netology1:~# test -d /tmp/some_dir && echo Hi
   >root@netology1:~#
   >```
   >Есть ли смысл использовать в bash `&&`, если применить `set -e`?

   При использовании в качестве разделителя команд bash символа `;` оболочка будет игнорировать коды выхода этапов исполнения. То есть, все указанные команды будут выполнены. Цитата из `man bash`:

   ```
   Commands separated by a ; are executed sequentially; the shell waits for each command to  terminate in turn.
   ```

   А в случае использования `&&` оболочка приступит к выполнению следующей команды только в случае успешного выполнения предыдущей, т.е. если её код выхода будет равен `0`. Цитата из `man bash`:

   ```
          command1 && command2

   command2 is executed if, and only if, command1 returns an exit status of zero (success).
   ```

   Выставление опции `set -e` меняет поведение оболочки: она будет закрыта если при исполнении последовательности команд какая-либо из них вернула ненулевой код выхода.  
   У этой опции есть ряд оговорок по применению, но в общем случае для неинтерактивной сессии нет смысла использовать `&&` совместно с `set -e`, так как исполнение будет прервано при первом неуспешном завершении команды из очереди исполнения.

1. >Из каких опций состоит режим bash `set -euxo pipefail` и почему его хорошо было бы использовать в сценариях?

   Данный режим bash рассмотрим по пунктам:

   - __-e__ - завершает работу оболочки в случае ненулевого кода возврата от команд, входящих в скрипт.  
   Эту опцию можно рассматривать как предохранитель от выполнения опасных команд при некорректных установках.  
   Пример: если `cd /some_path` не сможет найти желаемый путь, то нам не нужно чтобы выполнилась следующая команда `rm -rf ./*`.

   - __-u__ - прерывает неинтерактивную сессию оболочки в случае применения не заданной ранее (`unset`) переменной в скрипте.  
   Это защита от выполнения команд в неполностью подготовленной среде.

   - __-x__ - добавляет в вывод скрипта текст каждой команды с подставленными значениями переменных, но до непосредственного выполнения команд; добавленные строки имеют префикс - содержимое `$PS4`.  
   Эта опция - отличный инструмент для отладки скрипта: в `stdout` попадёт готовая расшифровка кода с указанием того, какие значения переменных были использованы в момент запуска команд; опция также может быть полезна при логировании работы скрипта.

   - __-o pipefail__ - включает опцию `pipefail`, которая меняет интерпретацию кода выхода всего пайпа. Без неё в расчёт берётся только код выхода последней составляющей пайпа, что скрывает проблемы с исполнением предшествующих команд в пайпе. Включение опции позволяет перехватывать ошибки выполнения независимо от расположения команды в пайпе (берётся ненулевой код выхода самой правой команды в последовательности).

   Резюмируя можно сказать, что приведённый режим работы оболочки позволяет быть увереным в том, что если скрипт вернул код выхода `0`, то успешно выполнились все составляющие его команды. А в случае расхождения предполагаемого поведения с реальным можно сразу оценить "стенографию" его исполнения для поиска "ошибки программиста", например неверный порядок определения переменных или ошибка в шаблоне фильтрации данных.

1. >Используя `-o stat` для `ps`, определите, какой наиболее часто встречающийся статус у процессов в системе. В `man ps` ознакомьтесь (`/PROCESS STATE CODES`) что значат дополнительные к основной заглавной буквы статуса процессов. Его можно не учитывать при расчете (считать S, Ss или Ssl равнозначными).

   Начну с того, что дополнительные символы в значении статуса процесса характеризуют его дополнительные свойства, такие как уровень приоритета, работу в `foreground` и другие.
   
   Теперь посчитаем сколько процессов в каком статусе находятся в системе:

   ```
   vagrant@vagrant:~$ ps -eo stat | grep -e '^.' -o | sort | uniq -c
     44 I
      1 R
     52 S
   ```

   Согласно статистике больше всего в системе процессов в статусе `S` (прерываемый сон), но также много и со статусом `I` (треды ядра в ожидании обращений).
